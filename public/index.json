
[{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/sample/","section":"Tags","summary":"","title":"Sample","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/users/","section":"Tags","summary":"","title":"Users","type":"tags"},{"content":"\rXiaomi Home Assistant是什么 #\r这是一个开源项目, 本质上是一个家庭 IoT设备的集成工具。实际上, 小米这个开源这个项目是基于另一个开源项目Home Assistant的二次开发。大家可以在Github里找到这两个开源项目: Xiaomi HS Xiaomi Home和 Home Assistant\n这个项目可谓得到广大 NAS和 IoT智能设备爱好者的追捧, githug上热度很高。当然这也是大势所趋, 现在很多电器都会带Wifi模块, 每个厂家的设备都给你开发一个APP, 最可恶的是, 每个厂家都对自己那点破数据敝帚自珍, 生怕让你知道控制设备发的什么命令。\n小米这一开源举动, 真的可谓是秦王扫六合的壮举, 至少将米家的所有智能设备控制接口都整合起来, 实乃广大爱折腾人士的福音。\n如何使用 #\r准备步骤 #\r前面说过小米的开源项目基于Home Assistant, 那么首先需要安装这个软件。可以点击这里安装\nHome Assistant 版本要求：\nCore $\\geq$ 2024.4.4 Operating System $\\geq$ 13.0 选择你需要安装的主体, 可以选择 树莓派, 手机, 或者 电脑\n我这里在电脑上安装, 选择这个\n然后,\n方法1 #\r你可以选择在电脑上安装一个操作系统: HAOS\n那么, 装在虚拟机里行不行? 应该是可以的, 但是虚拟机要获取Hardware的访问权限, 一般VMware或者Hyper-V都是可以的, 这里我们选择直接刷机,\n需要改UBOOT的设置, 这里就不介绍了。\n装好之后可以看到是一个类似Ubuntu的系统, 按照步骤来即可。\n方法2 #\r可以在现有系统上例如Ubuntu来通过Docker容器部署\n安装米家集成 #\r接下来, 要基于 HA 进行定制, 接下来就是 git的基本操作了, 直接使用 clone下来安装\ncd config git clone https://github.com/XiaoMi/ha_xiaomi_home.git cd ha_xiaomi_home ./install.sh /config 目前已经有很多个版本了, checkout到对应的版本\n例如，更新米家集成版本至 v1.0.0\ncd config/ha_xiaomi_home git checkout v1.0.0 ./install.sh /config 配置 #\r此部分按照官方的操作, 配置完就可以愉快的控制米家设备啦\n登录 #\r设置 \u0026gt; 设备与服务 \u0026gt; 添加集成 \u0026gt; 搜索“Xiaomi Home” \u0026gt; 下一步 \u0026gt; 请点击此处进行登录 \u0026gt; 使用小米账号登录\n添加 MIoT 设备 #\r登录成功后，会弹出会话框“选择家庭与设备”。您可以选择需要添加的米家家庭，该家庭内的所有设备将导入 Home Assistant 。\n多账号登录 #\r用一个小米账号登录并配置完成后，您可以在 Xiaomi Home Integration 页面中继续添加其他小米账号。\n方法：设置 \u0026gt; 设备与服务 \u0026gt; 已配置 \u0026gt; Xiaomi Home \u0026gt; 添加中枢 \u0026gt; 下一步 \u0026gt; 请点击此处进行登录 \u0026gt; 使用小米账号登录\n修改配置项 #\r在会话框“配置选项”中，可选择需要变更的配置项。您可以修改用户昵称或更新从米家 APP 导入的设备列表。\n方法：设置 \u0026gt; 设备与服务 \u0026gt; 已配置 \u0026gt; Xiaomi Home \u0026gt; 配置 \u0026gt; 选择需要变更的配置项\nAction 调试模式 #\r开启该模式后，您可手动向设备发送带参数的 Action 控制指令。发送带参数的 Action 控制指令的用户入口显示为一个文本实体。\n方法：设置 \u0026gt; 设备与服务 \u0026gt; 已配置 \u0026gt; Xiaomi Home \u0026gt; 配置 \u0026gt; Action 调试模式\n","date":"26 December 2024","externalUrl":null,"permalink":"/posts/xiaomi-home-assistant%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/","section":"Posts","summary":"","title":"Xiaomi Home Assistant折腾笔记","type":"posts"},{"content":"欢迎访问LNmint的博客\n本博客是作者随笔, 不做内容搬运工, 是工作经验的总结和提炼\nWisdom谈不上, 希望给你带来 Knowledge\n包括 IC/FPGA/Software/Hardware等的原创内容\n版权申明 如需转载请注明出处。\r","date":"26 December 2024","externalUrl":null,"permalink":"/","section":"欢迎访问LNmint的博客","summary":"","title":"欢迎访问LNmint的博客","type":"page"},{"content":"","date":"25 December 2024","externalUrl":null,"permalink":"/tags/arm/","section":"Tags","summary":"","title":"ARM","type":"tags"},{"content":"","date":"25 December 2024","externalUrl":null,"permalink":"/tags/ic/","section":"Tags","summary":"","title":"IC","type":"tags"},{"content":"https://blog.csdn.net/bukong123/article/details/134231895\n这里的JTAG是指符合IEEE 1149.1 JTAG的标准接口, 而非调试器\nJTAG标注架构 #\r先来看看JTAG的Architecture digram\n有四个接口pin:\nTDI TDO TMS TCK TCK就是时钟, TMS是测试模式选择, TDI/TDO分别是数据的in/out\n这样看, 是不是和SPI挺像的, 其实区别很大!\n为什么呢, 这个要从用途讲起, JTAG是一种调试接口, 我的芯片可能要去封装多个die, 或者有连接多个芯片调试的需求, 但是一般只会有一个JTAG口, 这怎么办呢?\n在SPI中, 我可以通过 CS来选中某个设备, 如果有两个设备, 那就CS0/CS1, 但如果有100个设备呢。。。\n在JTAG中有另外一种更节省管脚的实现方式, 在某一个device的数据包会直接发给下一个, 下一个拼接完再发给下下一个, 连接方式的话就是 TDO连接下一个JTAG设备的 TDI, 依次成链, 可以参考下图\n其实这种思想在片内总线中也有应用, 例如片内的环形总线。\n硬件连接 #\r就可以指导我们硬件连接了, TMS/TCK 这些信号按照菊花链的形式连接到所有device的JTAG, TDO和 TDI就按照首尾相接进行互联。\nZYNQ中的JTAG #\rZYNQ里面包括PS和PL两部分, 二者都是有JTAG接口的。\n在官方的手册中, 可以看到, 我们可以配置ZYNQ为两种模式:\n独立模式(Independent) 级联模式(Cascade) 独立模式就是这两各占一个JTAG接口, 在ARM端这个接口叫做DAP, 在PL端这个叫做TAP\n级联模式就是将两者在内部连接在一起, 只暴露出一个接口。但是我们能扫到两个设备!\nJTAG调试器 #\rJTAG调试器里装的是什么, 起什么作用, 价格差很多的两个调试器有什么区别, 为什么有的里面是一个FPGA?\n其实根据上文, 已经能大概猜出JTAG调试器里的是什么了。\nJTAG调试器要实现的功能就是一个JTAG的控制器, 如果JTAG Device是Slave, 那么JTAG盒子就是Master。\n一般里面是一个ASIC芯片, 但是用FPGA也能实现。\n","date":"25 December 2024","externalUrl":null,"permalink":"/posts/jtag%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE/","section":"Posts","summary":"","title":"JTAG接口协议","type":"posts"},{"content":"","date":"25 December 2024","externalUrl":null,"permalink":"/tags/%E5%8D%8F%E8%AE%AE/","section":"Tags","summary":"","title":"协议","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/posts/axi%E6%80%BB%E7%BA%BF/","section":"Posts","summary":"","title":"AXI总线","type":"posts"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/bus/","section":"Tags","summary":"","title":"BUS","type":"tags"},{"content":"","date":"23 December 2024","externalUrl":null,"permalink":"/tags/memory/","section":"Tags","summary":"","title":"Memory","type":"tags"},{"content":"PCB设计师只Know How, 不能Know Why。 DDR 地址线\n","date":"23 December 2024","externalUrl":null,"permalink":"/posts/%E4%BB%8Emc%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%9C%8Bsdram%E7%9A%84phy%E6%8E%A5%E5%8F%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1/","section":"Posts","summary":"","title":"从MC角度看看SDRAM的PHY接口-为什么要这样设计","type":"posts"},{"content":"","date":"23 December 2024","externalUrl":null,"permalink":"/tags/%E6%8E%A5%E5%8F%A3/","section":"Tags","summary":"","title":"接口","type":"tags"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/fpga/","section":"Tags","summary":"","title":"FPGA","type":"tags"},{"content":"纠错在计算机体系中非常常见, 在传输过程中以及存储过程中都有可能产生错误, 这其实非常常见。例如, 对于NAND Flash类型的存储介质(SD, EMMC, SSD等都属与这一类型), 通过在浮动栅极(floating gate)中存储电子来代表0和1, 在进行写或擦除等操作时, 电子会穿过浮动栅极, 而浮动栅极有个缺陷, 在电子反复穿过Floating Gate后, 电子存储的能力变弱, 那么所代表的0和1将不再可靠! 我们可以通过纠错算法来保证数据正确, 或磨损平衡的算法机制来提高整个存储介质的寿命和可靠性。当然我们这里不介绍磨损平衡。\n那么, 常用的纠错算法有哪些呢:\nECC #\r在正式介绍ECC之前, 我们先来看看Check Sum(校验和)。Check Sum是一种检错机制, 这个非常简单, 应用也非常广, 例如经典的UART协议中8bit数据后可以附1bit校验和, 分为奇校验和偶校验。\n在UART中Check Sum可以检查出8bit中的1bit误码。但这只是检错, 我们无法知道8bit中哪一个地址是错的。试想一下, 如果每1bit data都有1bit Check, 那就可以完成纠错了!\n但这样太傻了, 这不就相当于复制了一份吗, 效率直接砍了一半?\n那么ECC是怎么做的呢, 我们拿一张带ECC的内存条看看, 图中是一个带ECC的DDR内存条, 可以看到共使用了9个8bit位宽的SDRAM内存颗粒, 也就是总共72bit位宽, 其中64bit用于数据, 8bit用于ECC。\nECC是如何用8bit来完成64bit数据的纠错的。这其实很好理解, 我们只需要知道是哪个bit出错, 那么8bit可以包含的地址信息就是2^8=64个。\n当然, 真正的ECC远不止这些, 要真正使用, 还需要考虑如何计算, 能否在和data同一拍时钟给Memory Controller, 怎么计算效率高, 用的资源少。我们先按下不表。\n那么基于上面的情况, 我们深入一下:\n有没有可能数据是对的, 但是Check Sum算错了呢!!!? 此时我该相信谁? 那如果是2bit错误呢, 上述利用Check Sum就无能为力了。 FEC #\rFEC也就是前向纠错,\n","date":"16 December 2024","externalUrl":null,"permalink":"/posts/%E5%87%A0%E7%A7%8D%E7%BA%A0%E9%94%99%E7%AE%97%E6%B3%95/","section":"Posts","summary":"","title":"几种纠错算法","type":"posts"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/%E7%BA%A0%E9%94%99/","section":"Tags","summary":"","title":"纠错","type":"tags"},{"content":"","date":"11 December 2024","externalUrl":null,"permalink":"/tags/verilog/","section":"Tags","summary":"","title":"Verilog","type":"tags"},{"content":"\r关于状态机 #\r作为HDL的最基础知识，状态机无疑是非常重要的。 我们平时可能会碰到很多状态机，例如从简单的pattern检测，到PCIe的LTSSM，其实本质是一样的，好的状态机清晰明了，也是我们debug的利器；差的状态机各有千秋，可以让设计者落泪，也可以让使用者红温。 那么，如何写一个状态机呢？\n首先我们要明白为什么要有状态机。 答案很简单，为了顺序执行！\n如果没有状态机，我可以怎么写呢： if （a） else if（b） else if （c） 是的，这样就完成了简单的顺序控制，b依赖a，c依赖b，一层一层传递，这样可以吗？当然可以！设计是为结果服务的，对于简单的设计来说，这就很明了了。但稍微复杂一点，这就不够看了，逻辑会越嵌套越多，并且他们之间都是耦合的！很容易出错！\n好了，我们介绍正经的状态机了。按照教科书的说法，一般状态机分为Moore状态机和Mealy状态机。 Moore状态机：输出仅仅与当前状态有关； Mealy状态机：输出不仅取决于当前状态，还和输入有关； 好家伙，一上来就整两名词。但是这个更不重要，大多数情况下我们不需要研究我们写的是哪种。\n那么，最关键的，根据写法，我们可以概括为： 一段式 两段式 三段式 这才是真正简介，见文生义，且实用的命名！\n","date":"11 December 2024","externalUrl":null,"permalink":"/posts/rtl%E5%9F%BA%E7%A1%80%E4%B9%8B-%E7%8A%B6%E6%80%81%E6%9C%BA/","section":"Posts","summary":"","title":"关于状态机","type":"posts"},{"content":"","date":"21 November 2024","externalUrl":null,"permalink":"/tags/pcie/","section":"Tags","summary":"","title":"PCIe","type":"tags"},{"content":"\rPCIe #\rSource: Kindle\n📒 本书总结 #\rPCIE\nPCIe层级架构\n复位\nhttps://adaptivesupport.amd.com/s/question/0D52E00006hpaAbSAI/pci-express-wake-and-perst?language=en_US\n复位时序和最小复位时间\nTraining\n在系统复位后，会自动进行链路训练，以达成以下目标：位锁定（Bit Lock）、字符锁定（Symbol Lock，Gen1 \u0026amp; Gen2 Only）、块锁定（Block Lock，Gen3 Only）、确定链路宽度（Link Width）、通道位置翻转（Lane Reversal）、信号极性翻转（Polarity Inversion）、确定链路的数据率（Data Rate）和通道对齐（Lane-to-Lane De-skew）等功能。\n首先是位锁定（Bit Lock）：\n前面的文章中提到过，PCIe总线采用了一种嵌入式时钟的机制，即发送端只向接收端发送数据信号，并不发送时钟信号（时钟信号隐藏在数据信号中）。接收端可以通过CDR（Clock and Data Recovery）逻辑将时钟从数据流中恢复出来，然后再用恢复出来的时钟对数据信号进行采样。当然，时钟恢复需要一定的时间，才能保证时钟信号与数据信号的相位对应关系符合要求。一旦CDR完成了时钟的恢复，我们就说PCIe总线完成了位锁定。\n字符锁定（Symbol Lock）：\n完成了位锁定之后，只是能够准确地识别出数据流中的0和1，还是不知道发送的内容是个啥。对于Gen1\u0026amp;Gen2来说，采用的8b/10b编码，即传输的数据是以10bit为一个字符。LTSSM可以引导物理层相关逻辑通过识别COM（K28.5）等控制字符来确定每个字符的开始与结束为止，即字符锁定。\n链路宽度（Link Width）：\n由于PCIe允许将x1的PCIe卡插入x4、x8甚至是x16的PCIe插槽中。因此在链路训练与初始化过程中，相邻的两个PCIe设备需要相互通信来确定其支持的最大链路宽度。\n**注：**实际上PCIe Spec还允许采用动态带宽的机制，即允许链路宽度和数据率动态调整，以实现降低功耗等功能。\n通道位置翻转（Lane Reversal）：\n有的时候两个PCIe设备的通道排列位置可能不太一致，PCIe Spec允许对默认的通道排列位置重新排列，如下图所示。但是，从大部分的PCIe设备（PCIe卡和插槽等）都是按照统一的标准实现的，一般不会出现这种情况，因此这一功能是可选的。 - FAQ\nhttps://blog.csdn.net/u012158332/article/details/108902966\nReveral lane\n具体在Configuration阶段配置lane reversal,\nPolarity lane\n具体在LTSSM的polling轮训阶段\nPolling:\n这个阶段会进行train, bit对齐等。Polling.Active正式开始发送, 也就是所有lane会发送1024个TS1 order, 正常的话upstream/downstream都会收到连续的order, 那么就会进入config阶段\nPCIe测试 #\r需要考虑的因素\n","date":"21 November 2024","externalUrl":null,"permalink":"/posts/pcie%E7%BB%93%E6%9E%84/","section":"Posts","summary":"","title":"PCIe结构","type":"posts"},{"content":"","date":"21 November 2024","externalUrl":null,"permalink":"/tags/serdes/","section":"Tags","summary":"","title":"SerDes","type":"tags"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"\r🐍 ChipScoPy README #\rChipScoPy is an open-source project from Xilinx® that enables high-level control of Versal debug IP running in hardware.\nUsing a simple Python API, developers can control and communicate with ChipScope® debug IP such as the Integrated Logic\nAnalyzer (ILA), Virtual IO (VIO), device memory access, and more.\nChipScoPy communicates with Versal devices. It does not work with older devices such as Ultrascale+ and 7-Series devices.\nChipScoPy Overview\nSystem Requirements\nChipScoPy Installation\nChipScoPy Examples\nFAQ\nAPI Documentation\n","date":"20 November 2024","externalUrl":null,"permalink":"/posts/%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8chipscopy-%E4%BD%BF%E7%94%A8python%E5%AE%8C%E6%88%90%E8%B0%83%E8%AF%95/","section":"Posts","summary":"","title":"ChipScoPy使用","type":"posts"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/tags/debug/","section":"Tags","summary":"","title":"Debug","type":"tags"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/categories/fpga/","section":"Categories","summary":"","title":"FPGA","type":"categories"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/tags/xilinx/","section":"Tags","summary":"","title":"Xilinx","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]