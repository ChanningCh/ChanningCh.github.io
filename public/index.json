
[{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/categories/ic/","section":"Categories","summary":"","title":"IC","type":"categories"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/ipv6/","section":"Tags","summary":"","title":"IPV6","type":"tags"},{"content":"可能打印:\ninet 192.168.11.11 netmask 255.255.240.0 broadcast 192.168.11.11\rinet6 fe80:abcd:efff:f123:4567 prefixlen 64 scopeid 0x20 也有可能是:\ninet6 fe80::215:5dff:fed2:7d15 prefixlen 64 scopeid 0x20 ","date":"30 December 2024","externalUrl":null,"permalink":"/posts/%E4%BD%BF%E7%94%A8ipv6%E8%BF%9E%E6%8E%A5ssh/","section":"Posts","summary":"","title":"IPV6是什么","type":"posts"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/sample/","section":"Tags","summary":"","title":"Sample","type":"tags"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/users/","section":"Tags","summary":"","title":"Users","type":"tags"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/%E4%BB%A5%E5%A4%AA%E7%BD%91/","section":"Tags","summary":"","title":"以太网","type":"tags"},{"content":"欢迎访问LNmint的博客\n本博客是作者随笔, 不做内容搬运工, 是工作经验的总结和提炼\nWisdom谈不上, 希望给你带来 Knowledge\n包括 IC/FPGA/Software/Hardware等的原创内容\n版权申明 如需转载请注明出处。\r","date":"30 December 2024","externalUrl":null,"permalink":"/","section":"欢迎访问LNmint的博客","summary":"","title":"欢迎访问LNmint的博客","type":"page"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/nas/","section":"Tags","summary":"","title":"NAS","type":"tags"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/categories/tool/","section":"Categories","summary":"","title":"TOOL","type":"categories"},{"content":"","date":"30 December 2024","externalUrl":null,"permalink":"/tags/ubuntu/","section":"Tags","summary":"","title":"Ubuntu","type":"tags"},{"content":"\r准备 #\r首先, 需要准备一台主机安装Linux, 我使用的Linux发行版是Ubuntu最新的:\nUbuntu 24.04.1 LTS (Noble Numbat) 当然, Windows用户在WSL 2里装也是可以的。\n配置 #\r配置net-tools #\r先打开terminal查看IP地址\nifconfig # 打印示例 inet 192.168.11.11 netmask 255.255.240.0 broadcast 192.168.11.11 inet6 fe80::abc:defff:f123:4567 prefixlen 64 scopeid 0x20\u0026lt;link\u0026gt; 如果报错, 需要先安装\nsudo apt install net-tools Tips: apt和 apt-get都可以用, 两者用法也基本一致, 但从版本上来讲, 在Debian 8之后的版本(以及基于Debian的发行版, 例如Ubuntu), apt基本可以平替 apt-get\r安装SSH #\rUbuntu默认安装了SSH Client, 但是没有安装server, 直接执行:\nsudo apt install openssh-server 装好后, 可以更改 /etc/ssh/sshd_config 来配置SSH的执行默认启动方式, 有兴趣可以输入以下命令查看manual:\nman sshd_config 例如, 这里我可以更改登录时显示的页面, 在 /etc/ssh/sshd_config 中添加一行:\nBanner /etc/ssh/example.net 在example.net中输入你想要显示的标语, 例如:\n# example.net\r_.-- ,.--.\r.\u0026#39; .\u0026#39; /\r| @ |\u0026#39;..--------._\r/ \\._/ \u0026#39;.\r/ .-.- \\\r( / \\ \\\r\\\\ \u0026#39;. | #\r\\\\ \\ -. /\r:\\ | )._____.\u0026#39; \\\r\u0026#34; | / \\ | \\ )\r| | | | | / 修改完后, 可以先看看配置是否有错误:\nsudo sshd -t -f /etc/ssh/sshd_config 没有问题的话, 我们就可以启动了\nsudo /etc/init.d/ssh start\n或者, 如果启动过了, 可以执行restart\nsudo service ssh restart\n现在, 你就可以使用 ssh user@ip 的方式远程登录了, 我这里用的是 MobaXterm\n免密登录 #\rroot用户登录 #\rIPV6登录 #\r如果我的远程服务器和我的设备不在同一网段, 那么我们可以使用IPV6来进行登录, 可以参考我的另一篇博客: 使用IPV6登录SSH\ndocker安装 #\r","date":"30 December 2024","externalUrl":null,"permalink":"/posts/ubuntu-24.04%E4%B8%8A%E6%90%AD%E5%BB%BAnas/","section":"Posts","summary":"","title":"Ubuntu 24.04上搭建NAS","type":"posts"},{"content":"3.1.1 FEC方案选取 目前业界常用的FEC技术类型包括:  带内FEC: ITU-TG.707标准支持的带内FEC是利用SDH(Synchronous Digital Hierarchy)帧中的一部分比特用于装载FEC码的冗余码。其优点是不改变数据传输速率,但由于帧开销中可利用的比特数和帧长度有限,所以编码增益较低, 且需要基于SDH结构来封装实现, 并不适用于一般的测试场景。  带外FEC: 即在数据帧尾额外插入冗余编码来实现。优点是更加灵活, 可根据实际的使用场景来调整编码的冗余度和纠错能力, 而不受SDH帧格式的限制。  增强型FEC(EFEC): 是在带外FEC的基础上增加了级联信道编码等大增益编码技术, 主要应用于时延要求不严、编码增益要求特别高的通信场景。所谓级联信道编码, 即不仅对当前传输帧进行编码, 也会交织编码相邻帧, 可以实现跨frame间的纠错。级联码不仅具有较强的纠正突发错误、随机错误的能力, 提供更大的编码增益, 在特定的编码结构下, 基本可以达到纠错编码所给出的理论极限。但是, EFEC的编/解码过程比较复杂, 涉及的码型包括RS级联码、分组Turbo码和Goppa码等, 并且在交织编解码过程中引入了额外的延时。 在ITU-T G.975/G.709标准中既包含了支持带外基本FEC的协议, 也对EFEC中frame interleaving进行了规定(G.975 I.4)。FEC编码一般都基于Reed-Solomon编码及其变种实现, 表示为RS(n, k), 代表着通过对k 比特数据进行编码, 添加parity(长度为2t 比特)后组成n 比特长度的码型。通过Reed-Solomon编解码理论上最多可以实现t比特长度的纠错, 如下图所示。\n例如, 行业内常用的几种标准中: 在ITU-T G.975/G.709标准中规定的RS(255,239)格式编码, 在每239比特的帧尾插入了16比特冗余码, 编码后长度为255。其编码冗余度约为7%[(255-239)/239 = 0.066]), 可以完成最高8比特的纠错, 编码增益约为6dB。 在IEEE标准的802.3bs/802.3cd协议中采用RS(544, 514)纠错算法, 在每544个比特长度的数据帧里最多可以修正15个比特错误, 预计可允许最大2.4E-4的原始误码率。 3.1.2 编解码实现方案 以一种编码方式为例, 使用RS(544, 514) (即KP4)的编码过程如下:\n64b/66b编码到256b/257b编码转换。PCS层将从MAC层接收的64b/66b编码的相邻4个Symbol重新编码成257b的数据符号 加扰。对256b/257b编码的数据与PRBS扰码进行异或, 使得信号的整体频谱更接近随机信号的频谱分布 同步符号插入。在每条PCS的链路上插入相应的Align Marker信息用于接收端的链路同步。 符号分配和RS编码。在KP4的FEC编码过程中, 数据流以10280bit为单位进行编码。这些数据先分配成2个5140长度的编码字, 然后使用Reed-Solomon编码算法, 在每个编码字上增加30个10bit的校验符, 形成新的2个5440bit长度的编码字, 这两个编码字再进行交织并发送给PMA层 PMA层速率适配。经过编码后的PCS层根据链路速率进行适配和填充, 以达到目标速率, 并驱动PMA层进行信号传输。 在接收端经过PMA -\u0026gt; PCS -\u0026gt; RS解码的逆过程, 如果每个数据帧里符号错误的数量超过15个, 则错误不可修正, 并会把错误的不可修正的数据帧丢掉。对于交织数据, 例如每两个544符号长度的数据帧会进行交织, 一旦其中一个里的错误数量超过15个, 无法完成纠错, 那这两个数据帧都会被一起丢掉。 采用KP4编码需要依赖的Xilinx “100G IEEE 802.3bj Reed-Solomon Forward Error Correction” IP, 但是目前没有license, 且没有官方release的文档和example(目前通过Xilinx Secure Site拿到了一部分资料) 采用ITU-T G.975/G.709标准实现可以依赖使用Xilinx 的G.709 FEC Encoder/Decoder, G.975.1 EFEC I.4 Encoder/Decoder和G.975.1 EFEC I.7 Encoder/Decoder这几个IP。这几个IP在算法实现上有细微区别, G.709中标准化了EFEC中的交织方法(frame interleave), 而G.975中没有。此外, G.975中的239 bits data symbol中需包含1bit 帧头。但是这几个IP都没有对应的Guide和example。 本测试中采用ITU-T G.975/G.709标准实现。 3.1.3 与预计指标的偏离度 下表中列出了理论上经过RS(255,239)纠错前/后的误码率值(离散误码): BER before FEC BER after FEC 1.0E-3 8.6E-8 2.0E-4 2.0E-12 1.0E-4 5.0E-15 1.0E-5 6.3E-24 1.0E-6 6.4E-33\n","date":"27 December 2024","externalUrl":null,"permalink":"/posts/rs-fec%E7%AE%97%E6%B3%95/","section":"Posts","summary":"","title":"RS FEC算法","type":"posts"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/homeassistant/","section":"Tags","summary":"","title":"HomeAssistant","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/iot/","section":"Tags","summary":"","title":"IoT","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/tags/opensource/","section":"Tags","summary":"","title":"OpenSource","type":"tags"},{"content":"","date":"26 December 2024","externalUrl":null,"permalink":"/categories/opensource/","section":"Categories","summary":"","title":"OpenSource","type":"categories"},{"content":"\rXiaomi Home Assistant是什么 #\r这是一个开源项目, 本质上是一个家庭 IoT设备的集成工具。实际上, 小米这个开源这个项目是基于另一个开源项目Home Assistant的二次开发。大家可以在Github里找到这两个开源项目: Xiaomi HS Xiaomi Home和 Home Assistant\n这个项目可谓得到广大 NAS和 IoT智能设备爱好者的追捧, githug上热度很高。当然这也是大势所趋, 现在很多电器都会带Wifi模块, 每个厂家的设备都给你开发一个APP, 最可恶的是, 每个厂家都对自己那点破数据敝帚自珍, 生怕让你知道控制设备发的什么命令。\n小米这一开源举动, 真的可谓是秦王扫六合的壮举, 至少将米家的所有智能设备控制接口都整合起来, 实乃广大爱折腾人士的福音。\n如何使用 #\r准备步骤 #\r前面说过小米的开源项目基于Home Assistant, 那么首先需要安装这个软件。可以点击这里安装\nHome Assistant 版本要求：\nCore $\\geq$ 2024.4.4 Operating System $\\geq$ 13.0 选择你需要安装的主体, 可以选择 树莓派, 手机, 或者 电脑\n我这里在电脑上安装, 选择这个\n然后,\n方法1 #\r你可以选择在电脑上安装一个操作系统: HAOS\n那么, 装在虚拟机里行不行? 应该是可以的, 但是虚拟机要获取Hardware的访问权限, 一般VMware或者Hyper-V都是可以的, 这里我们选择直接刷机,\n需要改UBOOT的设置, 这里就不介绍了。\n装好之后可以看到是一个类似Ubuntu的系统, 按照步骤来即可。\n方法2 #\r可以在现有系统上例如Ubuntu来通过Docker容器部署\n安装米家集成 #\r接下来, 要基于 HA 进行定制, 接下来就是 git的基本操作了, 直接使用 clone下来安装\ncd config git clone https://github.com/XiaoMi/ha_xiaomi_home.git cd ha_xiaomi_home ./install.sh /config 目前已经有很多个版本了, checkout到对应的版本\n例如，更新米家集成版本至 v1.0.0\ncd config/ha_xiaomi_home git checkout v1.0.0 ./install.sh /config 配置 #\r此部分按照官方的操作, 配置完就可以愉快的控制米家设备啦\n登录 #\r设置 \u0026gt; 设备与服务 \u0026gt; 添加集成 \u0026gt; 搜索“Xiaomi Home” \u0026gt; 下一步 \u0026gt; 请点击此处进行登录 \u0026gt; 使用小米账号登录\n添加 MIoT 设备 #\r登录成功后，会弹出会话框“选择家庭与设备”。您可以选择需要添加的米家家庭，该家庭内的所有设备将导入 Home Assistant 。\n多账号登录 #\r用一个小米账号登录并配置完成后，您可以在 Xiaomi Home Integration 页面中继续添加其他小米账号。\n方法：设置 \u0026gt; 设备与服务 \u0026gt; 已配置 \u0026gt; Xiaomi Home \u0026gt; 添加中枢 \u0026gt; 下一步 \u0026gt; 请点击此处进行登录 \u0026gt; 使用小米账号登录\n修改配置项 #\r在会话框“配置选项”中，可选择需要变更的配置项。您可以修改用户昵称或更新从米家 APP 导入的设备列表。\n方法：设置 \u0026gt; 设备与服务 \u0026gt; 已配置 \u0026gt; Xiaomi Home \u0026gt; 配置 \u0026gt; 选择需要变更的配置项\nAction 调试模式 #\r开启该模式后，您可手动向设备发送带参数的 Action 控制指令。发送带参数的 Action 控制指令的用户入口显示为一个文本实体。\n方法：设置 \u0026gt; 设备与服务 \u0026gt; 已配置 \u0026gt; Xiaomi Home \u0026gt; 配置 \u0026gt; Action 调试模式\n","date":"26 December 2024","externalUrl":null,"permalink":"/posts/xiaomi-home-assistant%E6%8A%98%E8%85%BE%E7%AC%94%E8%AE%B0/","section":"Posts","summary":"","title":"Xiaomi Home Assistant折腾笔记","type":"posts"},{"content":"","date":"25 December 2024","externalUrl":null,"permalink":"/tags/arm/","section":"Tags","summary":"","title":"ARM","type":"tags"},{"content":"https://blog.csdn.net/bukong123/article/details/134231895\n这里的JTAG是指符合IEEE 1149.1 JTAG的标准接口, 而非调试器\nJTAG标注架构 #\r先来看看JTAG的Architecture digram\n有四个接口pin:\nTDI TDO TMS TCK TCK就是时钟, TMS是测试模式选择, TDI/TDO分别是数据的in/out\n这样看, 是不是和SPI挺像的, 其实区别很大!\n为什么呢, 这个要从用途讲起, JTAG是一种调试接口, 我的芯片可能要去封装多个die, 或者有连接多个芯片调试的需求, 但是一般只会有一个JTAG口, 这怎么办呢?\n在SPI中, 我可以通过 CS来选中某个设备, 如果有两个设备, 那就CS0/CS1, 但如果有100个设备呢。。。\n在JTAG中有另外一种更节省管脚的实现方式, 在某一个device的数据包会直接发给下一个, 下一个拼接完再发给下下一个, 连接方式的话就是 TDO连接下一个JTAG设备的 TDI, 依次成链, 可以参考下图\n其实这种思想在片内总线中也有应用, 例如片内的环形总线。\n硬件连接 #\r就可以指导我们硬件连接了, TMS/TCK 这些信号按照菊花链的形式连接到所有device的JTAG, TDO和 TDI就按照首尾相接进行互联。\nZYNQ中的JTAG #\rZYNQ里面包括PS和PL两部分, 二者都是有JTAG接口的。\n在官方的手册中, 可以看到, 我们可以配置ZYNQ为两种模式:\n独立模式(Independent) 级联模式(Cascade) 独立模式就是这两各占一个JTAG接口, 在ARM端这个接口叫做DAP, 在PL端这个叫做TAP\n级联模式就是将两者在内部连接在一起, 只暴露出一个接口。但是我们能扫到两个设备!\nJTAG调试器 #\rJTAG调试器里装的是什么, 起什么作用, 价格差很多的两个调试器有什么区别, 为什么有的里面是一个FPGA?\n其实根据上文, 已经能大概猜出JTAG调试器里的是什么了。\nJTAG调试器要实现的功能就是一个JTAG的控制器, 如果JTAG Device是Slave, 那么JTAG盒子就是Master。\n一般里面是一个ASIC芯片, 但是用FPGA也能实现。\n","date":"25 December 2024","externalUrl":null,"permalink":"/posts/jtag%E6%8E%A5%E5%8F%A3%E5%8D%8F%E8%AE%AE/","section":"Posts","summary":"","title":"JTAG接口协议","type":"posts"},{"content":"","date":"25 December 2024","externalUrl":null,"permalink":"/tags/%E5%8D%8F%E8%AE%AE/","section":"Tags","summary":"","title":"协议","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/axi/","section":"Tags","summary":"","title":"AXI","type":"tags"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/posts/axi%E6%80%BB%E7%BA%BF/","section":"Posts","summary":"","title":"AXI总线","type":"posts"},{"content":"","date":"24 December 2024","externalUrl":null,"permalink":"/tags/bus/","section":"Tags","summary":"","title":"BUS","type":"tags"},{"content":"","date":"23 December 2024","externalUrl":null,"permalink":"/categories/hardware/","section":"Categories","summary":"","title":"Hardware","type":"categories"},{"content":"","date":"23 December 2024","externalUrl":null,"permalink":"/tags/memory/","section":"Tags","summary":"","title":"Memory","type":"tags"},{"content":"PCB设计师只Know How, 不能Know Why。 DDR 地址线\n","date":"23 December 2024","externalUrl":null,"permalink":"/posts/%E4%BB%8Emc%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%9C%8Bsdram%E7%9A%84phy%E6%8E%A5%E5%8F%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1/","section":"Posts","summary":"","title":"从MC角度看看SDRAM的PHY接口-为什么要这样设计","type":"posts"},{"content":"","date":"23 December 2024","externalUrl":null,"permalink":"/tags/%E6%8E%A5%E5%8F%A3/","section":"Tags","summary":"","title":"接口","type":"tags"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/fpga/","section":"Tags","summary":"","title":"FPGA","type":"tags"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/ic/","section":"Tags","summary":"","title":"IC","type":"tags"},{"content":"纠错在计算机体系中非常常见, 在传输过程中以及存储过程中都有可能产生错误, 这其实非常常见。例如, 对于NAND Flash类型的存储介质(SD, EMMC, SSD等都属与这一类型), 通过在浮动栅极(floating gate)中存储电子来代表0和1, 在进行写或擦除等操作时, 电子会穿过浮动栅极, 而浮动栅极有个缺陷, 在电子反复穿过Floating Gate后, 电子存储的能力变弱, 那么所代表的0和1将不再可靠! 我们可以通过纠错算法来保证数据正确, 或磨损平衡的算法机制来提高整个存储介质的寿命和可靠性。当然我们这里不介绍磨损平衡。\n那么, 常用的纠错算法有哪些呢:\nECC #\r在正式介绍ECC之前, 我们先来看看Check Sum(校验和)。Check Sum是一种检错机制, 这个非常简单, 应用也非常广, 例如经典的UART协议中8bit数据后可以附1bit校验和, 分为奇校验和偶校验。\n在UART中Check Sum可以检查出8bit中的1bit误码。但这只是检错, 我们无法知道8bit中哪一个地址是错的。试想一下, 如果每1bit data都有1bit Check, 那就可以完成纠错了!\n但这样太傻了, 这不就相当于复制了一份吗, 效率直接砍了一半?\n那么ECC是怎么做的呢, 我们拿一张带ECC的内存条看看, 图中是一个带ECC的DDR内存条, 可以看到共使用了9个8bit位宽的SDRAM内存颗粒, 也就是总共72bit位宽, 其中64bit用于数据, 8bit用于ECC。\nECC是如何用8bit来完成64bit数据的纠错的。这其实很好理解, 我们只需要知道是哪个bit出错, 那么8bit可以包含的地址信息就是2^8=64个。\n当然, 真正的ECC远不止这些, 要真正使用, 还需要考虑如何计算, 能否在和data同一拍时钟给Memory Controller, 怎么计算效率高, 用的资源少。我们先按下不表。\n那么基于上面的情况, 我们深入一下:\n有没有可能数据是对的, 但是Check Sum算错了呢!!!? 此时我该相信谁? 那如果是2bit错误呢, 上述利用Check Sum就无能为力了。 FEC #\rFEC也就是前向纠错,\n","date":"16 December 2024","externalUrl":null,"permalink":"/posts/%E5%87%A0%E7%A7%8D%E7%BA%A0%E9%94%99%E7%AE%97%E6%B3%95/","section":"Posts","summary":"","title":"几种纠错算法","type":"posts"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/%E7%BA%A0%E9%94%99/","section":"Tags","summary":"","title":"纠错","type":"tags"},{"content":"","date":"11 December 2024","externalUrl":null,"permalink":"/categories/coding/","section":"Categories","summary":"","title":"Coding","type":"categories"},{"content":"","date":"11 December 2024","externalUrl":null,"permalink":"/tags/verilog/","section":"Tags","summary":"","title":"Verilog","type":"tags"},{"content":"\r关于状态机 #\r作为HDL的最基础知识，状态机无疑是非常重要的。 我们平时可能会碰到很多状态机，例如从简单的pattern检测，到PCIe的LTSSM，其实本质是一样的，好的状态机清晰明了，也是我们debug的利器；差的状态机各有千秋，可以让设计者落泪，也可以让使用者红温。 那么，如何写一个状态机呢？\n首先我们要明白为什么要有状态机。 答案很简单，为了顺序执行！\n如果没有状态机，我可以怎么写呢： if （a） else if（b） else if （c） 是的，这样就完成了简单的顺序控制，b依赖a，c依赖b，一层一层传递，这样可以吗？当然可以！设计是为结果服务的，对于简单的设计来说，这就很明了了。但稍微复杂一点，这就不够看了，逻辑会越嵌套越多，并且他们之间都是耦合的！很容易出错！\n好了，我们介绍正经的状态机了。按照教科书的说法，一般状态机分为Moore状态机和Mealy状态机。 Moore状态机：输出仅仅与当前状态有关； Mealy状态机：输出不仅取决于当前状态，还和输入有关； 好家伙，一上来就整两名词。但是这个更不重要，大多数情况下我们不需要研究我们写的是哪种。\n那么，最关键的，根据写法，我们可以概括为： 一段式 两段式 三段式 这才是真正简介，见文生义，且实用的命名！\n","date":"11 December 2024","externalUrl":null,"permalink":"/posts/rtl%E5%9F%BA%E7%A1%80%E4%B9%8B-%E7%8A%B6%E6%80%81%E6%9C%BA/","section":"Posts","summary":"","title":"关于状态机","type":"posts"},{"content":"","date":"21 November 2024","externalUrl":null,"permalink":"/tags/pcie/","section":"Tags","summary":"","title":"PCIe","type":"tags"},{"content":"\rPCIe #\rSource: Kindle\n📒 本书总结 #\rPCIE\nPCIe层级架构\n复位\nhttps://adaptivesupport.amd.com/s/question/0D52E00006hpaAbSAI/pci-express-wake-and-perst?language=en_US\n复位时序和最小复位时间\nTraining\n在系统复位后，会自动进行链路训练，以达成以下目标：位锁定（Bit Lock）、字符锁定（Symbol Lock，Gen1 \u0026amp; Gen2 Only）、块锁定（Block Lock，Gen3 Only）、确定链路宽度（Link Width）、通道位置翻转（Lane Reversal）、信号极性翻转（Polarity Inversion）、确定链路的数据率（Data Rate）和通道对齐（Lane-to-Lane De-skew）等功能。\n首先是位锁定（Bit Lock）：\n前面的文章中提到过，PCIe总线采用了一种嵌入式时钟的机制，即发送端只向接收端发送数据信号，并不发送时钟信号（时钟信号隐藏在数据信号中）。接收端可以通过CDR（Clock and Data Recovery）逻辑将时钟从数据流中恢复出来，然后再用恢复出来的时钟对数据信号进行采样。当然，时钟恢复需要一定的时间，才能保证时钟信号与数据信号的相位对应关系符合要求。一旦CDR完成了时钟的恢复，我们就说PCIe总线完成了位锁定。\n字符锁定（Symbol Lock）：\n完成了位锁定之后，只是能够准确地识别出数据流中的0和1，还是不知道发送的内容是个啥。对于Gen1\u0026amp;Gen2来说，采用的8b/10b编码，即传输的数据是以10bit为一个字符。LTSSM可以引导物理层相关逻辑通过识别COM（K28.5）等控制字符来确定每个字符的开始与结束为止，即字符锁定。\n链路宽度（Link Width）：\n由于PCIe允许将x1的PCIe卡插入x4、x8甚至是x16的PCIe插槽中。因此在链路训练与初始化过程中，相邻的两个PCIe设备需要相互通信来确定其支持的最大链路宽度。\n**注：**实际上PCIe Spec还允许采用动态带宽的机制，即允许链路宽度和数据率动态调整，以实现降低功耗等功能。\n通道位置翻转（Lane Reversal）：\n有的时候两个PCIe设备的通道排列位置可能不太一致，PCIe Spec允许对默认的通道排列位置重新排列，如下图所示。但是，从大部分的PCIe设备（PCIe卡和插槽等）都是按照统一的标准实现的，一般不会出现这种情况，因此这一功能是可选的。 - FAQ\nhttps://blog.csdn.net/u012158332/article/details/108902966\nReveral lane\n具体在Configuration阶段配置lane reversal,\nPolarity lane\n具体在LTSSM的polling轮训阶段\nPolling:\n这个阶段会进行train, bit对齐等。Polling.Active正式开始发送, 也就是所有lane会发送1024个TS1 order, 正常的话upstream/downstream都会收到连续的order, 那么就会进入config阶段\nPCIe测试 #\r需要考虑的因素\n","date":"21 November 2024","externalUrl":null,"permalink":"/posts/pcie%E7%BB%93%E6%9E%84/","section":"Posts","summary":"","title":"PCIe结构","type":"posts"},{"content":"","date":"21 November 2024","externalUrl":null,"permalink":"/tags/serdes/","section":"Tags","summary":"","title":"SerDes","type":"tags"},{"content":"ChipScoPy is an open-source project from Xilinx® that enables high-level control of Versal debug IP running in hardware.\nUsing a simple Python API, developers can control and communicate with ChipScope® debug IP such as the Integrated Logic\nAnalyzer (ILA), Virtual IO (VIO), device memory access, and more.\nChipScoPy communicates with Versal devices. It does not work with older devices such as Ultrascale+ and 7-Series devices.\nChipScoPy Overview\nSystem Requirements\nChipScoPy Installation\nChipScoPy Examples\nFAQ\nAPI Documentation\n","date":"20 November 2024","externalUrl":null,"permalink":"/posts/%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8chipscopy-%E4%BD%BF%E7%94%A8python%E5%AE%8C%E6%88%90%E8%B0%83%E8%AF%95/","section":"Posts","summary":"","title":"ChipScoPy使用","type":"posts"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/tags/debug/","section":"Tags","summary":"","title":"Debug","type":"tags"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/categories/debug/","section":"Categories","summary":"","title":"Debug","type":"categories"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/tags/xilinx/","section":"Tags","summary":"","title":"Xilinx","type":"tags"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]