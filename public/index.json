
[{"content":"","date":"23 December 2024","externalUrl":null,"permalink":"/tags/note/","section":"Tags","summary":"","title":"Note","type":"tags"},{"content":"","date":"23 December 2024","externalUrl":null,"permalink":"/posts/","section":"Posts","summary":"","title":"Posts","type":"posts"},{"content":"","date":"23 December 2024","externalUrl":null,"permalink":"/tags/","section":"Tags","summary":"","title":"Tags","type":"tags"},{"content":"","date":"23 December 2024","externalUrl":null,"permalink":"/tags/tech/","section":"Tags","summary":"","title":"Tech","type":"tags"},{"content":"PCB设计师只Know How, 不能Know Why。 DDR 地址线\n","date":"23 December 2024","externalUrl":null,"permalink":"/posts/%E4%BB%8Emc%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%9C%8Bsdram%E7%9A%84phy%E6%8E%A5%E5%8F%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1/%E4%BB%8Emc%E8%A7%92%E5%BA%A6%E7%9C%8B%E7%9C%8Bsdram%E7%9A%84phy%E6%8E%A5%E5%8F%A3-%E4%B8%BA%E4%BB%80%E4%B9%88%E8%A6%81%E8%BF%99%E6%A0%B7%E8%AE%BE%E8%AE%A1/","section":"Posts","summary":"","title":"从MC角度看看SDRAM的PHY接口-为什么要这样设计","type":"posts"},{"content":"一个分享IC/FPGA/编程/硬件等原创内容的博客 ","date":"23 December 2024","externalUrl":null,"permalink":"/","section":"欢迎来到LNmint的博客","summary":"","title":"欢迎来到LNmint的博客","type":"page"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/ecc/","section":"Tags","summary":"","title":"ECC","type":"tags"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/fec/","section":"Tags","summary":"","title":"FEC","type":"tags"},{"content":"纠错在计算机体系中非常常见, 在传输过程中以及存储过程中都有可能产生错误, 这其实非常常见。例如, 对于NAND Flash类型的存储介质(SD, EMMC, SSD等都属与这一类型), 通过在浮动栅极(floating gate)中存储电子来代表0和1, 在进行写或擦除等操作时, 电子会穿过浮动栅极, 而浮动栅极有个缺陷, 在电子反复穿过Floating Gate后, 电子存储的能力变弱, 那么所代表的0和1将不再可靠! 我们可以通过纠错算法来保证数据正确, 或磨损平衡的算法机制来提高整个存储介质的寿命和可靠性。当然我们这里不介绍磨损平衡。\n那么, 常用的纠错算法有哪些呢:\nECC #\r在正式介绍ECC之前, 我们先来看看Check Sum(校验和)。Check Sum是一种检错机制, 这个非常简单, 应用也非常广, 例如经典的UART协议中8bit数据后可以附1bit校验和, 分为奇校验和偶校验。\n在UART中Check Sum可以检查出8bit中的1bit误码。但这只是检错, 我们无法知道8bit中哪一个地址是错的。试想一下, 如果每1bit data都有1bit Check, 那就可以完成纠错了!\n但这样太傻了, 这不就相当于复制了一份吗, 效率直接砍了一半?\n那么ECC是怎么做的呢, 我们拿一张带ECC的内存条看看, 图中是一个带ECC的DDR内存条, 可以看到共使用了9个8bit位宽的SDRAM内存颗粒, 也就是总共72bit位宽, 其中64bit用于数据, 8bit用于ECC。\nECC是如何用8bit来完成64bit数据的纠错的。这其实很好理解, 我们只需要知道是哪个bit出错, 那么8bit可以包含的地址信息就是2^8=64个。\n当然, 真正的ECC远不止这些, 要真正使用, 还需要考虑如何计算, 能否在和data同一拍时钟给Memory Controller, 怎么计算效率高, 用的资源少。我们先按下不表。\n那么基于上面的情况, 我们深入一下:\n有没有可能数据是对的, 但是Check Sum算错了呢!!!? 此时我该相信谁? 那如果是2bit错误呢, 上述利用Check Sum就无能为力了。 FEC #\rFEC也就是前向纠错,\n","date":"16 December 2024","externalUrl":null,"permalink":"/posts/%E5%87%A0%E7%A7%8D%E7%BA%A0%E9%94%99%E7%AE%97%E6%B3%95/%E5%87%A0%E7%A7%8D%E7%BA%A0%E9%94%99%E7%AE%97%E6%B3%95/","section":"Posts","summary":"","title":"几种纠错算法","type":"posts"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/%E7%AE%97%E6%B3%95/","section":"Tags","summary":"","title":"算法","type":"tags"},{"content":"","date":"16 December 2024","externalUrl":null,"permalink":"/tags/%E7%BA%A0%E9%94%99/","section":"Tags","summary":"","title":"纠错","type":"tags"},{"content":"","date":"11 December 2024","externalUrl":null,"permalink":"/tags/verilog/","section":"Tags","summary":"","title":"Verilog","type":"tags"},{"content":"\r关于状态机 #\r作为HDL的最基础知识，状态机无疑是非常重要的。 我们平时可能会碰到很多状态机，例如从简单的pattern检测，到PCIe的LTSSM，其实本质是一样的，好的状态机清晰明了，也是我们debug的利器；差的状态机各有千秋，可以让设计者落泪，也可以让使用者红温。 那么，如何写一个状态机呢？\n首先我们要明白为什么要有状态机。 答案很简单，为了顺序执行！\n如果没有状态机，我可以怎么写呢： if （a） else if（b） else if （c） 是的，这样就完成了简单的顺序控制，b依赖a，c依赖b，一层一层传递，这样可以吗？当然可以！设计是为结果服务的，对于简单的设计来说，这就很明了了。但稍微复杂一点，这就不够看了，逻辑会越嵌套越多，并且他们之间都是耦合的！很容易出错！\n好了，我们介绍正经的状态机了。按照教科书的说法，一般状态机分为Moore状态机和Mealy状态机。 Moore状态机：输出仅仅与当前状态有关； Mealy状态机：输出不仅取决于当前状态，还和输入有关； 好家伙，一上来就整两名词。但是这个更不重要，大多数情况下我们不需要研究我们写的是哪种。\n那么，最关键的，根据写法，我们可以概括为： 一段式 两段式 三段式 这才是真正简介，见文生义，且实用的命名！\n","date":"11 December 2024","externalUrl":null,"permalink":"/posts/rtl%E5%9F%BA%E7%A1%80%E4%B9%8B-%E7%8A%B6%E6%80%81%E6%9C%BA/%E5%85%B3%E4%BA%8E%E7%8A%B6%E6%80%81%E6%9C%BA/","section":"Posts","summary":"","title":"关于状态机","type":"posts"},{"content":"\rPCIe #\rSource: Kindle\n📒 本书总结 #\rPCIE\nPCIe层级架构\n复位\nhttps://adaptivesupport.amd.com/s/question/0D52E00006hpaAbSAI/pci-express-wake-and-perst?language=en_US\n复位时序和最小复位时间\nTraining\n在系统复位后，会自动进行链路训练，以达成以下目标：位锁定（Bit Lock）、字符锁定（Symbol Lock，Gen1 \u0026amp; Gen2 Only）、块锁定（Block Lock，Gen3 Only）、确定链路宽度（Link Width）、通道位置翻转（Lane Reversal）、信号极性翻转（Polarity Inversion）、确定链路的数据率（Data Rate）和通道对齐（Lane-to-Lane De-skew）等功能。\n首先是位锁定（Bit Lock）：\n前面的文章中提到过，PCIe总线采用了一种嵌入式时钟的机制，即发送端只向接收端发送数据信号，并不发送时钟信号（时钟信号隐藏在数据信号中）。接收端可以通过CDR（Clock and Data Recovery）逻辑将时钟从数据流中恢复出来，然后再用恢复出来的时钟对数据信号进行采样。当然，时钟恢复需要一定的时间，才能保证时钟信号与数据信号的相位对应关系符合要求。一旦CDR完成了时钟的恢复，我们就说PCIe总线完成了位锁定。\n字符锁定（Symbol Lock）：\n完成了位锁定之后，只是能够准确地识别出数据流中的0和1，还是不知道发送的内容是个啥。对于Gen1\u0026amp;Gen2来说，采用的8b/10b编码，即传输的数据是以10bit为一个字符。LTSSM可以引导物理层相关逻辑通过识别COM（K28.5）等控制字符来确定每个字符的开始与结束为止，即字符锁定。\n链路宽度（Link Width）：\n由于PCIe允许将x1的PCIe卡插入x4、x8甚至是x16的PCIe插槽中。因此在链路训练与初始化过程中，相邻的两个PCIe设备需要相互通信来确定其支持的最大链路宽度。\n**注：**实际上PCIe Spec还允许采用动态带宽的机制，即允许链路宽度和数据率动态调整，以实现降低功耗等功能。\n通道位置翻转（Lane Reversal）：\n有的时候两个PCIe设备的通道排列位置可能不太一致，PCIe Spec允许对默认的通道排列位置重新排列，如下图所示。但是，从大部分的PCIe设备（PCIe卡和插槽等）都是按照统一的标准实现的，一般不会出现这种情况，因此这一功能是可选的。\nFAQ\nhttps://blog.csdn.net/u012158332/article/details/108902966\nReveral lane\n具体在Configuration阶段配置lane reversal,\nPolarity lane\n具体在LTSSM的polling轮训阶段\nPolling:\n这个阶段会进行train, bit对齐等。Polling.Active正式开始发送, 也就是所有lane会发送1024个TS1 order, 正常的话upstream/downstream都会收到连续的order, 那么就会进入config阶段\nPCIe测试 #\r需要考虑的因素\n","date":"21 November 2024","externalUrl":null,"permalink":"/posts/pcie%E7%BB%93%E6%9E%84/pcie%E7%BB%93%E6%9E%84/","section":"Posts","summary":"","title":"PCIe结构","type":"posts"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/categories/","section":"Categories","summary":"","title":"Categories","type":"categories"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/tags/chipscopy/","section":"Tags","summary":"","title":"ChipScoPy","type":"tags"},{"content":"\r🐍 ChipScoPy README #\rChipScoPy is an open-source project from Xilinx® that enables high-level control of Versal debug IP running in hardware.\nUsing a simple Python API, developers can control and communicate with ChipScope® debug IP such as the Integrated Logic\nAnalyzer (ILA), Virtual IO (VIO), device memory access, and more.\nChipScoPy communicates with Versal devices. It does not work with older devices such as Ultrascale+ and 7-Series devices.\nChipScoPy Overview\nSystem Requirements\nChipScoPy Installation\nChipScoPy Examples\nFAQ\nAPI Documentation\n","date":"20 November 2024","externalUrl":null,"permalink":"/posts/%E8%B0%83%E8%AF%95%E7%A5%9E%E5%99%A8chipscopy-%E4%BD%BF%E7%94%A8python%E5%AE%8C%E6%88%90%E8%B0%83%E8%AF%95/chipscopy%E4%BD%BF%E7%94%A8/","section":"Posts","summary":"","title":"ChipScoPy使用","type":"posts"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/tags/fpga/","section":"Tags","summary":"","title":"FPGA","type":"tags"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/categories/fpga/","section":"Categories","summary":"","title":"FPGA","type":"categories"},{"content":"","date":"20 November 2024","externalUrl":null,"permalink":"/tags/xilinx/","section":"Tags","summary":"","title":"Xilinx","type":"tags"},{"content":"","externalUrl":null,"permalink":"/posts/axi%E6%80%BB%E7%BA%BF/axi%E6%80%BB%E7%BA%BF/","section":"Posts","summary":"","title":"","type":"posts"},{"content":"","externalUrl":null,"permalink":"/authors/","section":"Authors","summary":"","title":"Authors","type":"authors"},{"content":"","externalUrl":null,"permalink":"/series/","section":"Series","summary":"","title":"Series","type":"series"}]